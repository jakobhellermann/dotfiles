"$schema" = "https://jj-vcs.github.io/jj/latest/config-schema.json"

[custom]
show-commit-id = false

[user]
name = "Jakob Hellermann"
email = "jakob.hellermann@protonmail.com"

[ui]
color = "always"
default-command = "log"
editor = "nvim"
diff-editor = "gitpatch"
conflict-marker-style = "git"
pager = "less -FRXS --wordwrap"
movement.edit = true

[colors]
"diff token".underline = false

[fix.tools.rustfmt]
command = ["rustfmt", "--emit", "stdout"]
patterns = ["glob:'**/*.rs'"]

[aliases]
sq = ['squash']
ab = ['abandon']
hsplit = ['split', '--parallel', '--config', 'ui.editor="true"']
hsquash = ['squash', '--from', 'siblings(@)']
megamerge = ['new', 'all:heads(trunk():: & mine())', '-m', 'dev']
dev = ['edit', 'dev']
all-rebase = ['rebase', '-s', 'all:roots(immutable_heads()..)', '-d', 'trunk()']
tug = ['bookmark', 'move', '--from', 'heads(::@- & bookmarks())', '--to', '@-']
nextconflict = ['edit', 'firstconflict']
fork = [
  'util',
  'exec',
  'sh',
  '--',
  '-c',
  '''
set -euo pipefail

if jj git remote list | grep 'upstream' >/dev/null; then
	echo "remote 'upstream' already exists"
	exit
fi
origin=$(jj git remote list | grep 'origin' | cut -d' ' -f2)

fork=$(yes no | gh repo fork "$origin" 2>&1 || true)
fork=$(echo "$fork" \
	| sed -r 's|https://github.com/|git@github.com:|' \
	| sed -r 's|(.*) already exists|git@github.com:\1|')

echo "$fork"

jj git remote rename origin upstream 2>/dev/null
jj config get "revset-aliases.'trunk()'" | sed 's/origin/upstream/' | xargs jj config set --repo "revset-aliases.'trunk()'"

jj git remote add origin "$fork"
''',
]

[revsets]
graph-prioritize = "coalesce(dev, present(main))"
log = "present(@) | ancestors(immutable_heads().., 4) | present(trunk())"

[revset-aliases]
firstconflict = "roots(conflicts())"
siblings = "siblings(@)"
dev = 'description(exact:"dev\n")'
'siblings(x)' = "x-+ ~x"

[templates]
log = 'builtin_log_oneline ++ if(!description && current_working_copy, diff.summary())'
op_log = 'builtin_op_log_oneline'
draft_commit_description = '''
concat(
  description,
  surround(
    "\nJJ: This commit contains the following changes:\n", "",
    indent("JJ:     ", diff.summary()),
  ),
  "JJ: ",
  "\nJJ: ignore-rest\n",
  diff.git(),
)
'''

[template-aliases]
'format_short_id(id)' = 'id.shortest(4)'
'format_short_signature(signature)' = 'signature.name()'
'format_timestamp(timestamp)' = 'timestamp.ago()'
'format_short_commit_id(id)' = 'if(config("custom.show-commit-id").as_boolean(), id.shortest(4))'
'format_operation_oneline(op)' = '''
  separate(" ",
    op.id().short(8), op.time().end().ago(),
    clean_operation_message(op.description().first_line()),
    if(op.tags(), op.tags()),
  )
'''
'clean_operation_message(msg)' = '''
coalesce(
  if(snapshot, label("empty", "snapshot")),
  if(msg.starts_with("squash commits into"), msg.substr(0, 28)),
  if(msg.starts_with("describe commit"), msg.substr(0, 24)),
  if(msg.starts_with("abandon commit"), msg.substr(0, 23)),
  if(msg.starts_with("undo operation"), msg.substr(0, 23)),
  if(msg.starts_with("split commit"), msg.substr(0, 21)),
  if(msg.starts_with("edit commit"), msg.substr(0, 20)),
  if(msg.starts_with("commit "), msg.substr(0, 15)),
  msg
)
'''

[merge-tools.gitpatch]
program = "sh"
edit-args = [
  "-c",
  '''
  set -eu
  rm -f "$right/JJ-INSTRUCTIONS"
  git -C "$left" init -q
  git -C "$left" add -A
  git -C "$left" commit -q -m baseline --allow-empty
  mv "$left/.git" "$right"
  git -C "$right" add --intent-to-add -A
  git -C "$right" add -p
  git -C "$right" diff-index --quiet --cached HEAD && { echo "No changes done, aborting split."; exit 1; }
  git -C "$right" commit -q -m split
  git -C "$right" restore . # undo changes in modified files
  git -C "$right" reset .   # undo --intent-to-add
  git -C "$right" clean -q -df # remove untracked files
  ''',
]
merge-args = ["-c", "echo gitpatch cannot be used as a merge tool"]
diff-args = ["-c", "echo gitpatch cannot be used as a diff tool"]
